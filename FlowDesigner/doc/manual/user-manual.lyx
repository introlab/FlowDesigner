#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass book
\begin_preamble
\usepackage{graphicx}
\usepackage{hyperref}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Overflow User's Manual
\layout Author

Jean-Marc Valin
\newline 
Dominic Létourneau
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Standard


\begin_inset LatexCommand \listoffigures{}

\end_inset 


\layout Chapter

What is Overflow?
\layout Standard


\latex latex 

\backslash 
href{http://freespeech.sourceforge.net/overflow.html}{Overflow}
\latex default 
 is a free (GPL/LGPL) "data-flow oriented" development environment.
 It can be use to build complex applications by combining small, reusable
 building blocks.
 In some way, it has similarities with Simulink and LabView, although it
 is not designed (and far) to be a "clone" of any of them.
 
\layout Standard

Overflow features a GUI that allows rapid application development and features
 a visual debugger.
 Although Overflow can be used as a rapid prototyping tool, it can still
 be used for building real-time applications, such as audio effects processing.
 Since overflow is not really an "interpreted language", it can be quite
 fast.
 
\layout Standard

It is written in C++ and features a plugin mechanism that allows new nodes/toolb
oxes to be easiliy added.
 Overflow currently includes the following toolboxes: 
\layout Itemize

Signal processing Speech processing (part of the 
\latex latex 

\backslash 
href{http://freespeech.sourceforge.net/}{Open Mind Speech}
\latex default 
 project) 
\layout Itemize

Vector quantization 
\layout Itemize

Neural network (MLP)
\layout Itemize

Fuzzy logic 
\layout Itemize

Real-time audio effect processing (early stage) 
\layout Itemize

Linear algebra using LAPACK (early stage) 
\layout Itemize

Image processing (early stage) 
\layout Standard

Future enhancements could provide toolkits for the following applications
 : 
\layout Itemize

Artificial Intelligence 
\layout Itemize

Audio Synthesis 
\layout Itemize

Robotics (In progres)
\layout Section

Terminology
\layout Standard

This section defines the concepts and terms used by Overflow and shows how
 they relate to C or Matlab constructs.
\layout Subsection

Nodes
\layout Standard

The basic processing using in Overflow is a Node, a Node is in all ways
 similar to a C or Matlab function.
 It takes some input data, performs some operations and send data out.
 
\layout Subsubsection

Built-in nodes
\layout Standard

A built-in Overflow node is written in C++ and is part of the Overflow code
 (or compiled in an Overflow toolbox, like Matlab's .mex files).
 In Overflow, all nodes are implemented as a class that derive (directly
 or indirectly) from a base class called "Node" (note that most nodes derive
 from "BufferedNode").
 Although the Overflow implementation of different nodes uses C++ inheritance
 mechanism (using classes), there's no reason for the user to be aware of
 that.
 For that reason, it's not recommended to refer to nodes as "types" or 
\begin_inset Quotes eld
\end_inset 

classes
\begin_inset Quotes erd
\end_inset 

 (e.g..
 if Overflow were written in C, nodes would be implemented as functions).
 
\layout Subsubsection

Sub-networks (composite nodes)
\layout Standard

An Overflow sub-network (or subnet) is a collection of connected nodes that
 can be used as if they were a single node.
 Most Overflow subnets will be saved into .n files, which are almost the
 exact equivalent of Matlab's .m files.
 There's no real C equivalent because C is a compiled language (although
 it could be seen as a C function calling other C function).
 
\layout Subsubsection

Node terminals (inputs/outputs)
\layout Standard

The inputs of an Overflow nodes are equivalent to the arguments to a Matlab/C
 function.
 The same for outputs, but while C is restricted to one return value, Overflow
 and Matlab can have several outputs.
 Node inputs and outputs are sometimes refered to as 
\begin_inset Quotes eld
\end_inset 

terminals
\begin_inset Quotes erd
\end_inset 

.
\layout Subsubsection

Node parameters
\layout Standard

Overflow node parameters are also equivalent to C/Matlab function arguments.
 The difference between node parameters and node inputs is that parameters
 cannot change at run-time.
 They are specified at "build-time" and stay constant throughout the run.
 For instance, the "Constant" node has no input, but has a parameter called
 "VALUE" that is returned as the output of the node.
 Using constants, you can always "transform" another node's input into a
 parameter (to the constant).
 The reverse is not true, however.
 Why then have parameters and not define every argument as an input? Mostly
 simplicity and run-time performance.
 Sometimes, it is just a lot easier to know certain arguments in advance
 and be sure that they don't change during the run.
 However, when possible, it is better to implement arguments as inputs,
 as this allows more flexibility.
\layout Subsection

Data Types
\layout Standard

Unlike Matlab, that only supports the complex-double-matrix type (well,
 that's not totally true, but...), Overflow (like C and C++) has support for
 many different types.
 The 
\begin_inset Quotes eld
\end_inset 

basic
\begin_inset Quotes erd
\end_inset 

 Overflow types are: Bool, Int, Float, Double, Stream and Vector.
 There are also toolbox-specific types, like FFNet (neural network), VQ
 (Vector Quantizer), GMM (Gaussian Mixture Model), ...
 
\layout Standard

Right now, the only way to define a new type in Overflow is by adding C++
 code for it in a toolbox (or the core).
 Eventually, there will (could?) be a way to pack data in a "struct" using
 Overflow nodes, but this is not implemented yet.
 
\layout Standard

Some Overflow Nodes expect a certain type of data as input/parameter and
 will generate a run-time exception (which will abort execution) if the
 wrong data type is used (e.g..
 a Load node expects a Stream as input and nothing else).
 Some nodes, like the NOP (no-op) node, can take any type as input.
 Some node have more complex behaviour, like the Add node that can add two
 floats, two Vectors of the same dimension, but cannot add a Bool and a
 Vector.
 
\layout Subsection

Links
\layout Standard

There's no real correspondence between Overflow links and C or Matlab constructs.
 The best analogy would be to say that Links represent the order of the
 lines in a C/Matlab function.
 You also need to keep in mind that Overflow uses a "pull method" in order
 to compute data.
 What does that mean? When you run a network, the last node (output node)
 of the main network (called "MAIN" -- how original!) is asked for its output.
 In order to compute its output, it needs to ask its input nodes for their
 output.
 That way everything propagates from the end to the beginning recursively.
 
\layout Standard

Now, why going backwards like that? That's a bit long to explain.
 The quick answer is "because".
 The longer answer involves faster handling of dependencies, faster processing,
 buffer management and things like that.
\layout Chapter

Getting started
\layout Standard

If called with no argument, the 
\emph on 
vflow
\emph default 
 program will start with a new empty Overflow document (fig.
 
\begin_inset LatexCommand \ref{fig:vflow_main}

\end_inset 

).
 It will already have a network named "MAIN".
 It is important that every "program" contain a network called "MAIN", which
 is equivalent to the 
\emph on 
main()
\emph default 
 function in a C program.
 You can add more sub-networks (equivalent of sub-routines) from the menu
 
\emph on 
Networks->Add Network
\emph default 
.
 
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 100 100
file vflow
width 4 90
flags 9

\end_inset 


\layout Caption

vflow main window
\begin_inset LatexCommand \label{fig:vflow_main}

\end_inset 


\end_float 
\layout Standard

You can then add nodes to your network by clicking on the right button in
 the background, select 
\emph on 
New Node
\emph default 
 and the type of node you want.
 The node inputs are displayed as a dot on the left side of each node, while
 the outputs are displayed on the right side.
 Inputs and outputs are called terminals.
 You can connect two nodes by clicking on a terminal and dragging the mouse
 to another terminal.
 Note that you cannot connect two outputs together, nor can you connect
 two inputs together.
 Except by using the 
\emph on 
Feedback
\emph default 
 node ("advanced" feature), you should not have feedback loops in your network.
 Links can be deleted by clicking on them with the SHIFT modifier on.
 
\layout Standard

Right-clicking on a node brings up the node menu.
 Selecting "Properties" in the node menu brings a dialog with parameters
 used by the node.
 Each parameter has a name a type and a value.
 Some of the parameters are mandatory, while some others are optional.
 See the node documentation for a description of all the parameters.
 
\layout Standard

All networks must have at least one output.
 Any network that is not a toplevel network (MAIN) may also have inputs.
 Inputs and outputs can be added by left clicking on a terminal with the
 SHIFT modifier on.
 You will be asked to provide the input/output name.
\layout Section

Using sub-networks (subnets) and iterators
\layout Standard

In order to simplify programming, you can create sub-networks (main menu
 Network->Add network) that can contain several nodes connected together.
 That way, you can reuse those networks as subnets in a higher level network.
 It is very important to name the newly created network a different name
 than "MAIN" for obvious reasons.
 Those networks must absolutely have "named" inputs and outputs in order
 to be used in higher level networks as explained in the previous section.
 
\layout Standard

Another useful type of network you can create is the Iterator (main menu
 Network->Add iterator).
 An iterator, is a control structure that performs a loop.
 It stops looping when a certain "control condition" is met.
 The condition is a boolean value the iterator gets from a node.
 To define the iterator's condition, left click on a node output while holding
 the CONTROL (or ALT) modifier.
 Note that there is a bug in some versions of gnome for which CONTROL does
 not work with the canvas, so you'll have to use ALT.
\layout Standard

For now, Threaded Iterators are experimental.
 You should not use them, unless you REALLY know what you are doing.
\layout Section

Executing an Overflow program
\layout Standard

When your program is complete, you can execute it by clicking "Run" in the
 toolbar.
 If an error occurs, the program will abort and the error will be printed
 in the text box in the bottom pane.
 Node that as of 0.6.0, the created documents have execute permission and
 can be executed as a like a script, provided that the batchflow executable
 is in the path.
\layout Chapter

Advanced features
\layout Section

Feed-back loops
\layout Standard

In some circumstances, it is desirable to insert feed-back loops into a
 program.
 Normaly, Overflow only supports acyclic graphs, but feed-back loops can
 be made using the special 
\emph on 
Feedback
\emph default 
 node.
\layout Section

Exceptions
\layout Subsection

Run-time exceptions
\layout Standard

First, it is important to note that there are two types of exceptions that
 can happen.
 The first type, which we'll call 
\emph on 
run-time exceptions
\emph default 
, is thrown (usually by a node) when an error happens during processing
 by Overflow.
 Such type of exception can be thrown when a node receives an object of
 an unexpected type, but there can be many other causes.
 Run-time exceptions usually terminate the current Overflow program with
 an error message indicating where the error happened.
 They are analoguous to run-time errors in most interpreted languages.
 
\layout Standard

It is possible to prevent a run-time exception from stopping a program.
 This can be done with the 
\emph on 
Recover
\emph default 
 node, that catches all run-time exceptions.
\layout Subsection

User exceptions
\layout Standard

The second type of exceptions, 
\emph on 
user exceptions
\emph default 
, can be thrown and caught by a user program using the 
\emph on 
Throw
\emph default 
 and 
\emph on 
Catch
\emph default 
 nodes.
 They are serve the same function as the 
\emph on 
throw
\emph default 
 and 
\emph on 
catch
\emph default 
 statements in a C++ program.
\layout Section

Multi-threading
\layout Standard

It must first be noted that multi-threading in Overflow is still an experimental
 feature and not all structures are fully MT-safe.
 Overflow multi-threading is provided through three special nodes: 
\emph on 
SerialThread
\emph default 
, 
\emph on 
ParallelThread
\emph default 
 and 
\emph on 
ThreadJoin
\emph default 
.
\layout Subsection

SerialThread
\layout Standard

The 
\emph on 
SerialThread
\emph default 
 node provides the type of multi-threading known as pipelining.
\layout Subsection

ParallelThread
\layout Standard

The 
\emph on 
ParallelThread
\emph default 
 node provides parallelism-type multi-threading.
\layout Subsection

ThreadJoin
\layout Standard

The 
\emph on 
ThreadJoin
\emph default 
 node acts like a mutex and prevents
\layout Chapter

Automatic C++ code generation
\layout Standard

Is is now possible to generate C++ code from an Overflow .n file.
 You can do that by clicking the "Build" button on the toolbar.
 Doing so brings up the code generation dialog (fig.
 
\begin_inset LatexCommand \ref{fig:codegen}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 100 100
file codegen
width 4 60
flags 9

\end_inset 


\layout Caption

Code generation dialog
\begin_inset LatexCommand \label{fig:codegen}

\end_inset 


\end_float 
\layout Standard

The "Build function name" is the name given to the function that will return
 the network (
\family typewriter 
Network *
\family default 
) corresponding to the XML file.
 You will only care if you want to build a library or if you want multiple
 networks.
 The "Output file name" option specifies the name of the C++ file that builds
 the network.
 Of course, "Directory" specifies where to put all that.
 
\layout Standard

There are 3 code generation options: 
\layout Itemize

Generate main: Check that if you want to build an application (as opposed
 to a library) 
\layout Itemize

Static linkage: This will copy all the required Overflow files in the same
 directory.
 This will allow to build an application/library without linking to Overflow.
 Note that the Overflow license (LGPL) still applies to the copied files.
 
\layout Itemize

Generate makefile: Un-implemented yet 
\layout Standard

Note: the 
\family typewriter 
VFLOW_SOURCE
\family default 
 environment variable must be set to your Overflow source directory in order
 for the "static linkage" option to work.
\the_end
